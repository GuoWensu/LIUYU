/*5-3最小重量机器设计问题

1.问题描述：设某一机器由n个部件组成，每一种部件都可以从m个不同的供应商处购得。设 Wij 是从供应商j 处购得的部件i的重量，Cij 是相应的价格。
试设计一个回溯算法，对于给定的机器部件重量和机器部件价格，计算总价格不超过c的最小重量机器设计。

2.算法设计：对于给定的机器部件重量和机器部件价格，计算总价格不超过d的最小重量机器设计。

3.解题思想：由于题目已经给出总价格的上限，因此算法通过使用回溯来选择合适的机器使得在总价格不超过d时得到的机器重量最小。首先初始化当前价格cp=0,
            当前重量cw=0,此外，还要设置一个变量best表示选择机器的总重量，初始化其为每个部件从1号供应商购买的重量。在循环选择i号机器时，
			判断从j号供应商购买机器后的价格是否大于总价格，如果不大于则选择，否则不选，继续选择下一供应商进行判断。在得到一个合适的供应商后，
			继续选择下一机器的供应商，从第一个选到最后一个供应商。当所有机器选择结束后，判断得到的总重量是否比之前的best小，如果小就赋给best，
			然后从这一步开始，回溯到上一机器，选择下一合适供应商，继续搜索可行解，直到将整个排列树搜索完毕。这样，最终得到的best即为最优解。 
*/
#include<stdio.h>
int n,m,d; 
int value[100][100],weight[100][100];
int best[100]={0};//最佳选择方案
int min=1000000;//最小重量 
int b[100]={0};//当前的选择方案 
int cw=0;//当前总重量 
int cp=0;//当前总价值 
void traceback(int num)
{
    int i;
    if(num==n) { 
        if(cw<min) {
            min=cw; //更新最小重量 
            for(i=0;i<n;i++)
                best[i]=b[i]+1;//更新最佳选择方案，数组从0开始，输出要加1  
        }
        return ;
    }
    for(i=0;i<m;i++) { //有m个供应商可供选择
        b[num]=i;
        cw+=weight[num][i];
        cp+=value[num][i];
        if(cw<min && cp<=d) //等号必须加 
            traceback(num+1);
        cw-=weight[num][i];
        cp-=value[num][i];
        b[num]=0;
    }
}

int main()
{
    int i,j;//部件i，供应商j
    scanf("%d%d%d",&n,&m,&d);//输入n个部件，m个供应商，总价格不超过d
    for(i=0;i<n;i++) {
        for(j=0;j<m;j++) {
            scanf("%d",&value[i][j]);//从供应商j处购得的部件i的价值
        }
    }
    for(i=0;i<n;i++) {
        for(j=0;j<m;j++) {
            scanf("%d",&weight[i][j]);//从供应商j处购得的部件i的重量
        }
    }
    traceback(0);
    printf("最小重量为 %d\n",min);
    for(i=0;i<n;i++) {
        printf("供应商为%d ",best[i]);
    }
    printf("\n");
    return 0;
}
